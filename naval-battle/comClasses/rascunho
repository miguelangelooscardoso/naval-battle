#include <iostream>
#include <vector>
#include <cstdlib>
#include <ctime>
#include <Windows.h> // Para PlaySound, caso esteja usando Windows

using namespace std;

// Definição das constantes para o tamanho do tabuleiro
#define LINHAS 10
#define COLUNAS 10
#define TIPOS_DE_EMBARCACAO 5

// Definição da classe Embarcacao
class Embarcacao {
public:
    char tipo;
    int tamanho;
    int quantidade;

    // Construtor para inicializar os valores
    Embarcacao(char t, int tam, int quant)
        : tipo(t), tamanho(tam), quantidade(quant) {}

    // Função para gerar embarcações (essa função será ajustada)
    void gerarEmbarcacoes(std::vector<Embarcacao> *embarcacoes, char tabuleiro[LINHAS][COLUNAS]);
};

// Definição da classe Jogador
class Jogador {
public:
    string nome;
    char tabuleiro[LINHAS][COLUNAS];
    char tentativas[LINHAS][COLUNAS];
    bool ativo;

    Jogador(string nome) : nome(nome) {}
};

// Função para inicializar a matriz do tabuleiro
void inicializarMatriz(char tabuleiro[LINHAS][COLUNAS]) {
    for (int i = 0; i < LINHAS; i++) {
        for (int j = 0; j < COLUNAS; j++) {
            tabuleiro[i][j] = ' ';
        }
    }
}

// Função para gerar as embarcações
void Embarcacao::gerarEmbarcacoes(std::vector<Embarcacao> *embarcacoes, char tabuleiro[LINHAS][COLUNAS]) {
    bool escritaPossivel;
    
    for (int k = 0; k < TIPOS_DE_EMBARCACAO; k++) {
        for (int l = 0; l < (*embarcacoes)[k].quantidade; l++) {
            do {
                int xAleatorio = rand() % LINHAS;
                int yAleatorio = rand() % COLUNAS;
                int direcao = rand() % 2; // 0 = horizontal, 1 = vertical

                escritaPossivel = true;
                
                // Verificar se a embarcação cabe na posição aleatória
                for (int i = 0; i < (*embarcacoes)[k].tamanho; i++) {
                    if (direcao == 1) { // vertical
                        if (xAleatorio + i >= LINHAS || tabuleiro[xAleatorio + i][yAleatorio] != ' ') {
                            escritaPossivel = false;
                            break;
                        }
                    } else { // horizontal
                        if (yAleatorio + i >= COLUNAS || tabuleiro[xAleatorio][yAleatorio + i] != ' ') {
                            escritaPossivel = false;
                            break;
                        }
                    }
                }

                if (escritaPossivel) {
                    for (int j = 0; j < (*embarcacoes)[k].tamanho; j++) {
                        if (direcao == 1) {
                            tabuleiro[xAleatorio + j][yAleatorio] = (*embarcacoes)[k].tipo;
                        } else {
                            tabuleiro[xAleatorio][yAleatorio + j] = (*embarcacoes)[k].tipo;
                        }
                    }
                }
            } while (!escritaPossivel);
        }
    }
}

// Função de turno de cada jogador (exemplo, você deve definir a função de acordo com a lógica do jogo)
void turnoJogador(Jogador *jogadorAtivo, Jogador *oponente, bool *jogarNovamente) {
    // Exemplo simples para demonstrar estrutura
    cout << jogadorAtivo->nome << " - Seu turno!" << endl;
    // Aqui o código de lógica do turno seria implementado
    *jogarNovamente = false; // Substitua pela lógica real de continuidade do jogo
}

// Função principal do jogo
void jogo(Jogador *jogador1, Jogador *jogador2, vector<Embarcacao> *embarcacoes) {
    inicializarMatriz(jogador1->tabuleiro);
    inicializarMatriz(jogador2->tabuleiro);

    inicializarMatriz(jogador1->tentativas);
    inicializarMatriz(jogador2->tentativas);

    // Chama a função para gerar as embarcações nos tabuleiros dos jogadores
    jogador1->gerarEmbarcacoes(embarcacoes, jogador1->tabuleiro);
    jogador2->gerarEmbarcacoes(embarcacoes, jogador2->tabuleiro);

    bool jogarNovamente = true;
    jogador1->ativo = true;
    jogador2->ativo = false;

    while (true) {
        system("cls");

        if (jogador1->ativo) {
            turnoJogador(jogador1, jogador2, &jogarNovamente);
        } else if (jogador2->ativo) {
            turnoJogador(jogador2, jogador1, &jogarNovamente);
        }

        cout << "\tPressione 'Enter' para a ir para jogada seguinte." << endl;
        cout << "\t>";
        cin.ignore();  // Limpa o buffer de entrada
    }
}

int main() {
    setlocale(LC_ALL, "pt_PT.UTF-8");
    srand(time(0)); // necessário para gerar um x,y aleatório

    PlaySound(TEXT("exemplo.wav"), NULL, SND_FILENAME | SND_ASYNC); // compile as 'g++ main.cpp -o main -lwinmm'

    // Definição do vetor de embarcações
    vector<Embarcacao> embarcacoes = {
        Embarcacao('A', 5, 1),
        Embarcacao('B', 4, 2),
        Embarcacao('C', 3, 3),
        Embarcacao('D', 2, 4),
        Embarcacao('E', 1, 5)
    };

    // Criação dos jogadores
    Jogador jogador1("Jogador 1");
    Jogador jogador2("Jogador 2");

    // Chamada da função jogo, passando ponteiro para embarcacoes
    jogo(&jogador1, &jogador2, &embarcacoes);

    return 0;
}

void Jogador::executarTurno(Jogador *jogador, Jogador *oponente, bool *jogarNovamente, bool isComputer)
{
    std::string nomeJogador = isComputer ? "Computador" : jogador->getNome();
    std::cout << "\t\t\tÉ a sua vez do ";
    definirCor(1);
    std::cout << nomeJogador;
    definirCor(7);
    std::cout << "!" << std::endl;
    
    imprimir(oponente->getTabuleiro(), jogador->getTentativas());
    *jogarNovamente = isComputer ? tentativasComputador(jogador) : inserirTentativas(jogador);
    system("cls");
    imprimir(oponente->getTabuleiro(), jogador->getTentativas());
    std::cout << "\tJogador 1: " << jogador->getPontos() << " pontos\t\tJogador 2: " << oponente->getPontos() << " pontos." << std::endl;
}
